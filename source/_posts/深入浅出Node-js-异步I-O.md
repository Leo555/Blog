---
title: 《深入浅出Node.js》-异步I/O
date: 2018-05-25 22:20:38
categories: Node
tags:
- 异步
- JavaScript
- I/O    
---

## 第三章 异步 I/O

异步的概念首先在 Web2.0 中火起来，是因为浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。前端通过异步的方式来消除 UI 阻塞的现象。假如业务场景中有一组互不相关的任务需要完成，可以采用下面两种方式。

1. 单线程串行一次执行。
2. 多线程并行执行。

如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。多线程的代价在于创建线程和执行期间线程上下文切换的开销较大。另外，在复杂业务中，多线程编程经常面临锁、状态同步等问题。但是多线程能有效利用 CPU。

单线程顺序执行比较符合编程人员按照顺序思考的思维方式，也是最主流的编程方式。缺点在于执行性能，任何一个略慢的任务都会导致后续执行代码被阻塞。

Node 在两者之间给出了它的方案：利用单线程，远离多线程死锁，状态同步问题；利用异步 I/O，让单线程远离阻塞，更好地利用 CPU。

异步 I/O 就是 I/O 的调用不再阻塞后续计算，将原有等待 I/O 完成这段时间分配给其它需要的业务去执行。

<!--more-->

### 异步 I/O 和 非阻塞 I/O

从计算机内核 I/O 而言，同步/异步和阻塞/非阻塞实际上是不同的。操作系统内核对 I/O 只有两种方式，阻塞和非阻塞。在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才返回结果。阻塞 I/O 造成 CPU 等待 I/O，CPU 的处理能力得不到充分利用。为了提高性能，内核提供了非阻塞 I/O。非阻塞 I/O 在调用之后立马返回，但是数据并不在返回结果中，返回结果中只有当前调用的状态。为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成。这种方式叫做轮询。

非阻塞 I/O 技术虽然不会让 CPU 等待造成浪费，但是却需要轮询去确认是否完成数据获取，其实也是对 CPU 资源的浪费。

主要轮询技术：

(1) read。反复调用来检查 I/O 的状态。
(2) select。通过文件描述符上的事件状态进行判断，select 轮询采用 1024 长度数组存储状态。
(3) poll。使用链表，减少不必要的检查。
(4) epoll。该方案是 Linux 下效率最高的 I/O 事件通知机制。在进入轮询的时候如果没有检查到 I/O 事件，将会进行休眠，知道事件发生将它唤醒。

## Node 的异步 I/O

### 事件循环

事件循环是 Node 自身的执行模型，正是它使得回调函数十分普遍。

在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体成为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们，然后进入下个循环，直到没有事件处理，就退出进程。

### 观察者

在每个 Tick 的过程中，如何判断是否有事件需要处理呢？Node 在每个事件循环中都有一个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。

在 Node 中，事件主要来源于网络请求，文件 I/O 等。事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者哪里，事件循环则从观察者那里取出事件并处理。