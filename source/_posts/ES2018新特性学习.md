---
title: ES2018新特性学习
date: 2018-07-02 19:47:59
categories: JavaScript
tags:
- ES2018
- ES9
---

ECMAScript 2018 (ES9) 在 6 月底正式发布，带来了很多新特性。关于 ES7 和 ES8 相关的知识，可以查看这篇文章 [ES2016 和 ES2017 学习](https://lz5z.com/ES2016%E5%92%8CES2017%E5%AD%A6%E4%B9%A0/)。目前大部分 ES7 和 ES8 的特性都得到主流浏览器的支持，而 ES9 的新特性还未能实现很好的兼容性。

关于 ES7/8/9 全部特性可以查看 tc39 官方的 [proposals](https://github.com/tc39/proposals/blob/master/finished-proposals.md)，这些都是最后进入 stage 4 的特性。

ES9 的新特性：

1. Lifting template literal restriction 模板语法修正
2. `s` (dotAll) flag for regular expressions (正则表达式 dotAll 模式)
3. RegExp named capture groups (正则表达式命名捕获组)
4. Rest/Spread Properties (Rest/Spread 属性)
5. RegExp Lookbehind Assertions (正则表达式反向(lookbehind)断言)
6. RegExp Unicode Property Escapes (正则表达式 Unicode 转义)
7. Promise.prototype.finally
8. Asynchronous Iteration (异步迭代器)

<!--more-->

## [正则表达式 dotAll 模式](https://github.com/tc39/proposal-regexp-dotall-flag)

dotAll 是一个新的正则表达式修饰符，目前 JS 拥有的修饰符有：

- g -> global
- i -> ingoreCase
- m -> multiline
- y -> sticky
- u -> unicode
- s -> dotAll

正则表达式中的 `.` 用来匹配任何单个字符，但是有 2 个除外：多字节 emoji 字符和行终结符。

```javascript
let regex = /^.$/
regex.test('😀')   // false
```

通过设置 u 表示 unicode

```javascript
let regex = /^.$/u
regex.test('😀')   // true
```

行终止符包括

- U+000A LINE FEED (LF) (\n) - 换行
- U+000D CARRIAGE RETURN (CR) (\r) - 回车
- U+2028 LINE SEPARATOR - 行分隔符
- U+2029 PARAGRAPH SEPARATOR - 段分隔符

还有一些其它字符，也可以作为一行的开始：

- U+000B VERTICAL TAB (\v)
- U+000C FORM FEED (\f)
- U+0085 NEXT LINE

目前 `.` 只能匹配其中的一部分：

```javascript
let regex = /./

regex.test('\n')       // false
regex.test('\r')       // false
regex.test('\u{2028}') // false
regex.test('\u{2029}') // false

regex.test('\v')       // true
regex.test('\f')       // true
regex.test('\u{0085}') // true
```

标记 `s` 表示 dotAll，用来改变 `.` 不能匹配行终止符的行为:

```javascript
/hello.world/.test('hello\nworld')  // false
/hello.world/s.test('hello\nworld') // true
```

或者用 `\s` 来匹配空白符：

```javascript
/hello.world/.test('hello\nworld')  // false
/hello[\s]world/s.test('hello\nworld') // true
```

dotAll 表示 `.` 可以匹配任意字符：

```javascript
const re = /hello.world/s  // 等价于 const re = new RegExp('hello.world', 's')

re.test('hello\nworld') // true
re.dotAll // true
re.flags // 's'
```

## [正则表达式命名捕获组](https://github.com/tc39/proposal-regexp-named-groups)

捕获组就是把正则表达式中匹配到的内容，保存到内存中以数字编号或者显式命名的数组里，方便后面使用。这种引用既可以在正则表达式内部，也可以是在正则表达式外部。

捕获组有两种形式，一种是普通捕获组，另一种是命名捕获组。

```javascript
const regex = /(\d{4})-(\d{2})-(\d{2})/
const matchers = regex.exec('2018-07-02')
matchers[0]    // 2018-07-02
matchers[1]    // 2018
matchers[2]    // 07
matchers[3]    // 02
```

使用数字捕获组的一个缺点是对于引用不太直观，以上面的例子，我们很难分清楚哪个组代表的是年，哪个组代表的是月。而命名捕获组就是为了解决这个问题。

### 命名捕获组

ES2018 允许命名捕获组可以使用 `(?<name>...)` 语法给每个组起一个名字。

```javascript
const regex = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/
const match = regex.exec('2018-07-02')
console.log(match.groups.day) // '02'
console.log(match.groups.month) // '07'
console.log(match.groups.year) // '2018'
```

### 名字唯一

每个捕获组的名字必须唯一，否则会抛出异常。

```javascript
const regex = /(?<foo>\d)-(?<foo>\d)/
// Uncaught SyntaxError: Invalid regular expression: /(?<foo>\d)-(?<foo>\d)/: Duplicate capture group name
```

### 匹配失败

任何匹配失败的命名组都将返回 undefined。

```javascript
let re = /^(?<optional>\d+)?$/
const matchers = re.exec('')

matchers[0] === ''
matchers.groups.optional === undefined
```

### 使用结构赋值

```javascript
let re = /^(?<one>.*):(?<two>.*)$/
let {groups: {one, two}} = re.exec('foo:bar')
console.log(`one: ${one}, two: ${two}`)  // 输出 one: foo, two: bar
```

### 使用 replace

```javascript
const reDate = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/
const d = '2018-07-02'
console.log(d.replace(reDate, '$<month>-$<day>-$<year>')) // 07-02-2018
```

`String.prototype.replace` 第 2 个参数可以接受一个函数。这时 命名捕获组的引用会作为 groups 参数传递进去:

```javascript
let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/

let result = '2018-07-02'.replace(re, (...args) => {
  let {day, month, year} = args[args.length - 1]
  return `${day}-${month}-${year}`
})

result === '02/07/2018' // true
```

### 反向引用

当需要在正则表达式里面引用命名捕获组时，使用 `\k<name>` 语法。

```javascript
let duplicate = /^(?<half>.*).\k<half>$/
duplicate.test('a*b') // false
duplicate.test('a*a') // true
```	

### 向下兼容

`/(?<name>)/` 和 `/\k<foo>/` 只有在命名捕获组中才有意义。如果正则表达式没有命名捕获组，那么 `/\k<foo>/` 仅仅是字符串字面量 "k<foo>" 而已。

```javascript
/\k<foo>/.test('k<foo>')   // true
```

## [正则表达式反向(lookbehind)断言](https://github.com/tc39/proposal-regexp-lookbehind)

断言 (Assertion) 是一个对当前匹配位置之前或之后的字符的测试，它不会实际消耗任何字符，所以断言也被称为“非消耗性匹配”或“非获取匹配”。

正则表达式的断言一共有 4 种形式：

- `(?=pattern)` 零宽正向肯定断言(zero-width positive lookahead assertion)
- `(?!pattern)` 零宽正向否定断言(zero-width negative lookahead assertion)
- `(?<=pattern)` 零宽反向肯定断言(zero-width positive lookbehind assertion)
- `(?<!pattern)` 零宽反向否定断言(zero-width negative lookbehind assertion)

### 正向断言(lookahead)

当前位置后面的字符串应该满足断言，但是并不捕获，在当前的 JavaScript 正则表达式只支持正向断言。

```javascript
const regex = /li(?=zhen)/
const match1 = regex.exec('lizhen')
console.log(match1[0]) // li
// 如果字符串没有zhen，则无法匹配
const match2 = regex.exec('liming')
console.log(match2) // null
```

正向否定断言正好相反

```javascript
const regex = /li(?!zhen)/

const match1 = regex.exec('lizhen')
console.log(match1)    // null

const match2 = regex.exec('liming')
console.log(match2[0]) // li
```

### 反向断言(lookbehind)

反向断言和正向断言的行为一样，只是方向相反。反向肯定断言使用语法 `(?<=...)`。

比如我们想获取所有的人民币金额，但是不获取其它货币（比如美元）：

```javascript
const regex = /(?<=\D)\d+(\.\d*)?/
const match = regex.exec('$123.89')
console.log(match[0]) // 123.89
```

## [正则表达式 Unicode 转义](https://github.com/tc39/proposal-regexp-unicode-property-escapes)




## 参考文档

- [esnext](http://esnext.justjavac.com/proposal/)
- [[译] ES2018（ES9）的新特性](https://juejin.im/post/5b2a186cf265da596d04a648)